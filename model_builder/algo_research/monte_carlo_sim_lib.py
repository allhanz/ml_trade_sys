#website:http://www.pythonforfinance.net/2016/11/28/monte-carlo-simulation-in-python/

#import necessary packages
import numpy as np
import math
import matplotlib.pyplot as plt
from scipy.stats import norm
from pandas_datareader import data
 
def pi_monte_carlo_sim():
    # 投点次数
    n = 10000

    # 圆的信息
    r = 1.0         # 半径
    a, b = (0., 0.) # 圆心

    # 正方形区域边界
    x_min, x_max = a-r, a+r
    y_min, y_max = b-r, b+r

    # 在正方形区域内随机投点
    x = np.random.uniform(x_min, x_max, n) # 均匀分布
    y = np.random.uniform(y_min, y_max, n)

    # 计算 点到圆心的距离
    d = np.sqrt((x-a)**2 + (y-b)**2)

    # 统计 落在圆内的点的数目
    res = sum(np.where(d < r, 1, 0))

    # 计算 pi 的近似值（Monte Carlo方法的精髓：用统计值去近似真实值）
    pi = 4 * res / n

    print('pi: ', pi)

    '''
    # 画个图看看
    fig = plt.figure() 
    axes = fig.add_subplot(111) 
    axes.plot(x, y,'ro',markersize = 1)
    plt.axis('equal') # 防止图像变形

    circle = Circle(xy=(a,b), radius=r, alpha=0.5)
    axes.add_patch(circle)

    plt.show()
    '''

def definite_integral_monte_carlo_sim():
    '''蒙特卡罗方法求函数 y=x^2 在[0,1]内的定积分（值）'''
    def f(x):
        return x**2

    # 投点次数
    n = 10000

    # 矩形区域边界
    x_min, x_max = 0.0, 1.0
    y_min, y_max = 0.0, 1.0     

    # 在矩形区域内随机投点
    x = np.random.uniform(x_min, x_max, n) # 均匀分布
    y = np.random.uniform(y_min, y_max, n)

    # 统计 落在函数 y=x^2图像下方的点的数目
    res = sum(np.where(y < f(x), 1, 0))

    # 计算 定积分的近似值（Monte Carlo方法的精髓：用统计值去近似真实值）
    integral = res / n

    print('integral: ', integral)

    '''
    # 画个图看看
    fig = plt.figure() 
    axes = fig.add_subplot(111) 
    axes.plot(x, y,'ro',markersize = 1)
    plt.axis('equal') # 防止图像变形

    axes.plot(np.linspace(x_min, x_max, 10), f(np.linspace(x_min, x_max, 10)), 'b-') # 函数图像
    #plt.xlim(x_min, x_max)

    plt.show()
    '''

def main():
    pi_monte_carlo_sim()
    definite_integral_monte_carlo_sim()
    print("not tested....")

if __name__=="__main__":
    main()

'''
#download Apple price data into DataFrame
apple = data.DataReader('AAPL', 'google',start='1/1/2000')
 
#calculate the compound annual growth rate (CAGR) which 
#will give us our mean return input (mu) 
days = (apple.index[-1] - apple.index[0]).days
cagr = ((((apple['Adj Close'][-1]) / apple['Adj Close'][1])) ** (365.0/days)) - 1
print ('CAGR =',str(round(cagr,4)*100)+"%")
mu = cagr
 
#create a series of percentage returns and calculate 
#the annual volatility of returns
apple['Returns'] = apple['Adj Close'].pct_change()
vol = apple['Returns'].std()*sqrt(252)
print ("Annual Volatility =",str(round(vol,4)*100)+"%")


#Define Variables
S = apple['Adj Close'][-1] #starting stock price (i.e. last available real stock price)
T = 252 #Number of trading days
mu = 0.2309 #Return
vol = 0.4259 #Volatility
 
#create list of daily returns using random normal distribution
daily_returns=np.random.normal((mu/T),vol/math.sqrt(T),T)+1
 
#set starting price and create price series generated by above random daily returns
price_list = [S]
 
for x in daily_returns:
    price_list.append(price_list[-1]*x)
 
#Generate Plots - price series and histogram of daily returns
plt.plot(price_list)
plt.show()
plt.hist(daily_returns-1, 100) #Note that we run the line plot and histogram separately, not simultaneously.
plt.show()


#Define Variables
S = apple['Adj Close'][-1] #starting stock price (i.e. last available real stock price)
T = 252 #Number of trading days
mu = 0.2309 #Return
vol = 0.4259 #Volatility
 
#create list of daily returns using random normal distribution
daily_returns=np.random.normal((mu/T),vol/math.sqrt(T),T)+1
 
#set starting price and create price series generated by above random daily returns
price_list = [S]
 
for x in daily_returns:
    price_list.append(price_list[-1]*x)
 
#Generate Plots - price series and histogram of daily returns
plt.plot(price_list)
plt.show()
plt.hist(daily_returns-1, 100) #Note that we run the line plot and histogram separately, not simultaneously.
plt.show()

import math
import matplotlib.pyplot as plt
from scipy.stats import norm
 
#set up empty list to hold our ending values for each simulated price series
result = []
 
#Define Variables
S = apple['Adj Close'][-1] #starting stock price (i.e. last available real stock price)
T = 252 #Number of trading days
mu = 0.2309 #Return
vol = 0.4259 #Volatility
 
#choose number of runs to simulate - I have chosen 10,000
for i in range(10000):
    #create list of daily returns using random normal distribution
    daily_returns=np.random.normal(mu/T,vol/math.sqrt(T),T)+1
    
    #set starting price and create price series generated by above random daily returns
    price_list = [S]
    
    for x in daily_returns:
        price_list.append(price_list[-1]*x)
 
    #plot data from each individual run which we will plot at the end
    plt.plot(price_list)
    
    #append the ending value of each simulated run to the empty list we created at the beginning
    result.append(price_list[-1])
 
#show the plot of multiple price series created above
plt.show()
 
#create histogram of ending stock values for our mutliple simulations
plt.hist(result,bins=50)
plt.show()
#use numpy mean function to calculate the mean of the result
print(round(np.mean(result),2))
print("5% quantile =",np.percentile(result,5))
print("95% quantile =",np.percentile(result,95))
plt.hist(result,bins=100)
plt.axvline(np.percentile(result,5), color='r', linestyle='dashed', linewidth=2)
plt.axvline(np.percentile(result,95), color='r', linestyle='dashed', linewidth=2)
plt.show()
'''